// home screen code



import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:math';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  // Local Storage State
  List<String> _localCodes = [];
  int _localIndex = 0;
  String _localBatchId = ""; // Track the version of codes we have
  bool _isLoadingCodes = true;

  @override
  void initState() {
    super.initState();
    _loadLocalData();
  }

  // ==========================================
  // 1. DATA SYNC & LOGIC (BATCH ID SYSTEM)
  // ==========================================

  // Load codes from Phone Memory on startup
  Future<void> _loadLocalData() async {
    final prefs = await SharedPreferences.getInstance();
    setState(() {
      _localCodes = prefs.getStringList('offline_codes') ?? [];
      _localIndex = prefs.getInt('offline_index') ?? 0;
      _localBatchId = prefs.getString('batch_id') ?? "";
      _isLoadingCodes = false;
    });
  }

  // The Master Sync Function (Called whenever DB changes)
  Future<void> _checkAndSyncCodes(DocumentSnapshot boxDoc) async {
    final data = boxDoc.data() as Map<String, dynamic>;
    final String boxId = boxDoc.id;
    
    // Safety Checks
    if (!data.containsKey('offlineCodes')) return;
    
    List<dynamic> dbCodes = data['offlineCodes'];
    String dbBatchId = data['batchId'] ?? "0"; // The Master Version from DB
    List<dynamic> codePool = data['codePool'] ?? [];
    
    // SYNC CHECK: Do we have the WRONG batch?
    // If DB has codes, and our local Batch ID doesn't match the DB Batch ID
    if (dbCodes.isNotEmpty && dbBatchId != _localBatchId) {
      print(">>> APP: Version Mismatch! (DB: $dbBatchId vs Local: $_localBatchId). Force Updating...");
      
      final prefs = await SharedPreferences.getInstance();
      List<String> stringCodes = dbCodes.map((e) => e.toString()).toList();
      
      // Overwrite Local Data with new Batch
      await prefs.setStringList('offline_codes', stringCodes);
      await prefs.setInt('offline_index', 0); 
      await prefs.setString('batch_id', dbBatchId); // Update Version Stamp

      setState(() {
        _localCodes = stringCodes;
        _localIndex = 0;
        _localBatchId = dbBatchId;
      });
      
      // Let DB know we are synced
      await FirebaseFirestore.instance.collection('boxes').doc(boxId).update({'appSynced': true});
    }
    // Note: We also set 'appSynced' if it's just a normal first-time sync
    else if (dbCodes.isNotEmpty && (data['appSynced'] == false)) {
       // This handles the case where versions match but flag wasn't set (rare, but safe)
       await FirebaseFirestore.instance.collection('boxes').doc(boxId).update({'appSynced': true});
    }

    // REFILL LOGIC (If both App & Device have consumed the current batch)
    bool appSynced = data['appSynced'] ?? false;
    bool boxSynced = data['boxSynced'] ?? false;

    if (appSynced && boxSynced) {
      print(">>> APP: Both Synced. Triggering Smart Refill...");
      await _refillCodes(boxId, codePool);
    }
  }

  // --- AUTOMATION HELPERS ---

  // Generate Safe Codes (No 3, 6, 9)
  List<String> _generateNewBatch(int count) {
    final rng = Random();
    // Hardware-Safe List: Excludes 3, 6, 9
    const allowedDigits = ['0', '1', '2', '4', '5', '7', '8']; 
    final Set<String> codes = {};
    
    while (codes.length < count) {
      String code = "";
      for (int i = 0; i < 6; i++) {
        code += allowedDigits[rng.nextInt(allowedDigits.length)];
      }
      codes.add(code);
    }
    return codes.toList();
  }

  // Smart Refill Function (Pool -> Active + Auto-Generate)
  Future<void> _refillCodes(String boxId, List<dynamic> currentPool) async {
    List<dynamic> updatedPool = List.from(currentPool);

    // 1. AUTO-REFILL: If pool is low, generate 500 new safe codes immediately
    if (updatedPool.length < 10) {
      print(">>> SYSTEM: Reserve low (<10). Auto-generating 500 safe codes...");
      List<String> freshCodes = _generateNewBatch(500);
      updatedPool.addAll(freshCodes); 
    }

    // 2. MOVE CODES: Take next 10 for Active Batch
    if (updatedPool.length >= 10) {
      List<dynamic> newBatch = updatedPool.sublist(0, 10);
      List<dynamic> remainingPool = updatedPool.sublist(10);
      
      // Generate NEW Batch ID (Timestamp) to signal a version change
      String newBatchId = DateTime.now().millisecondsSinceEpoch.toString();

      // 3. ATOMIC UPDATE
      await FirebaseFirestore.instance.collection('boxes').doc(boxId).update({
        'offlineCodes': newBatch,
        'codePool': remainingPool,
        'batchId': newBatchId, // Crucial for Sync
        'appSynced': false, // Reset flags for next cycle
        'boxSynced': false,
        'offlineIndex': 0, // Reset DB index just in case
      });
      
      print(">>> SYSTEM: Refill Complete. New Batch ID: $newBatchId");
    }
  }

  // ==========================================
  // 2. STRICT AUTO-DELETE LISTENER
  // ==========================================
  
  // This widget silently listens to the history collection for usage events
  Widget _buildHistoryListener(String internalId) {
    return StreamBuilder<QuerySnapshot>(
      stream: FirebaseFirestore.instance
          .collection('boxes')
          .doc(internalId)
          .collection('history')
          .orderBy('timestamp', descending: true)
          .limit(1)
          .snapshots(),
      builder: (context, snapshot) {
        if (!snapshot.hasData || snapshot.data!.docs.isEmpty) return const SizedBox();

        final data = snapshot.data!.docs.first.data() as Map<String, dynamic>;
        final String action = data['action'] ?? "";
        final String codeUsed = data['codeUsed'] ?? "";

        // Logic: If device reports usage of CURRENT code -> Delete it locally
        if (action == "OFFLINE_UNLOCK" && _localCodes.isNotEmpty) {
          if (_localIndex < _localCodes.length) {
            String currentDisplayedCode = _localCodes[_localIndex];
            
            // IF MATCH: The code we are showing was just used on the device!
            if (codeUsed == currentDisplayedCode) {
              WidgetsBinding.instance.addPostFrameCallback((_) {
                _advanceToNextCode();
              });
            }
          }
        }
        return const SizedBox(); 
      },
    );
  }

  Future<void> _advanceToNextCode() async {
    final prefs = await SharedPreferences.getInstance();
    int newIndex = _localIndex + 1;
    
    // Prevent multiple triggers for the same index
    int storedIndex = prefs.getInt('offline_index') ?? 0;
    if (newIndex > storedIndex) {
      await prefs.setInt('offline_index', newIndex);
      
      if (mounted) {
        setState(() { _localIndex = newIndex; });
        
        // Close the dialog if it's open
        if (Navigator.canPop(context)) Navigator.pop(context); 
        
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text("Code used successfully! Removed from App."),
            backgroundColor: Colors.green,
            duration: Duration(seconds: 3),
          )
        );
      }
    }
  }

  // ==========================================
  // 3. UI WIDGETS
  // ==========================================

  @override
  Widget build(BuildContext context) {
    final user = FirebaseAuth.instance.currentUser;

    if (user == null) {
      return const Center(child: CircularProgressIndicator());
    }

    return Scaffold(
      backgroundColor: const Color(0xFFF6F7FB),
      // AppBar with Admin Button
      appBar: AppBar(
        backgroundColor: const Color(0xFFF6F7FB),
        elevation: 0,
        actions: [
          StreamBuilder<QuerySnapshot>(
            stream: FirebaseFirestore.instance
                .collection('boxes')
                .where('assignedTo', isEqualTo: user.uid)
                .limit(1)
                .snapshots(),
            builder: (context, snapshot) {
              if (!snapshot.hasData || snapshot.data!.docs.isEmpty) {
                return const SizedBox();
              }
              final internalId = snapshot.data!.docs.first.id;
              return IconButton(
                icon: const Icon(Icons.settings, color: Colors.black54),
                tooltip: "Admin Setup",
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                        builder: (context) => AdminSetupScreen(boxId: internalId)),
                  );
                },
              );
            },
          )
        ],
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(20),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              StreamBuilder<DocumentSnapshot>(
                stream: FirebaseFirestore.instance.collection('users').doc(user.uid).snapshots(),
                builder: (context, snapshot) {
                  final username = snapshot.data?.get('username') ?? 'User';
                  return _buildHeader(username);
                },
              ),

              const SizedBox(height: 24),

              // Main Box Stream
              StreamBuilder<QuerySnapshot>(
                stream: FirebaseFirestore.instance
                    .collection('boxes')
                    .where('assignedTo', isEqualTo: user.uid)
                    .limit(1)
                    .snapshots(),
                builder: (context, boxSnap) {
                  if (boxSnap.connectionState == ConnectionState.waiting) {
                    return const Center(child: CircularProgressIndicator());
                  }

                  if (!boxSnap.hasData || boxSnap.data!.docs.isEmpty) {
                    return _buildNoBoxState(context, user.uid);
                  }

                  final boxDoc = boxSnap.data!.docs.first;
                  final internalId = boxDoc.id;
                  final data = boxDoc.data() as Map<String, dynamic>;
                  final displayId = data['publicBoxId'] ?? data['boxId'] ?? 'Unknown ID';
                  final isLocked = data['isLocked'] ?? true;

                  // ðŸ”¥ TRIGGER SYNC CHECK
                  _checkAndSyncCodes(boxDoc);

                  // Online Logic
                  bool isOnline = false;
                  if (data.containsKey('lastSeen') && data['lastSeen'] != null) {
                    try {
                      final Timestamp lastSeen = data['lastSeen'];
                      final int diff = DateTime.now().difference(lastSeen.toDate()).inSeconds;
                      if (diff < 60) isOnline = true;
                    } catch (e) {
                      isOnline = false;
                    }
                  }

                  return Column(
                    children: [
                      // Invisible Listener for Auto-Delete
                      _buildHistoryListener(internalId),

                      _buildModernDashboard(
                        context, 
                        internalId, 
                        displayId, 
                        isLocked, 
                        isOnline
                      ),
                      
                      const SizedBox(height: 24),

                      // OFFLINE OTP CARD
                      // Only show if box is Offline (Phase 2 requirement)
                      if (!isOnline) 
                        _buildOfflineCard(context),
                      
                      // Optional: Helper text when Online
                      if (isOnline)
                        const Padding(
                          padding: EdgeInsets.all(20),
                          child: Text(
                            "Device is Online. Use the standard Unlock button above.", 
                            style: TextStyle(color: Colors.green, fontStyle: FontStyle.italic),
                            textAlign: TextAlign.center,
                          ),
                        ),
                    ],
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  // --- WIDGET BUILDERS ---

  Widget _buildHeader(String username) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          'Welcome Back,',
          style: TextStyle(color: Colors.grey, fontSize: 16),
        ),
        const SizedBox(height: 4),
        Text(
          username,
          style: const TextStyle(
            color: Colors.black87,
            fontSize: 26,
            fontWeight: FontWeight.bold,
          ),
        ),
      ],
    );
  }

  Widget _buildModernDashboard(BuildContext context, String internalId, String displayId, bool isLocked, bool isOnline) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Box Status Card
        Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(24),
            boxShadow: [
              BoxShadow(
                color: Colors.grey.withOpacity(0.08),
                blurRadius: 20,
                offset: const Offset(0, 10),
              ),
            ],
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text("Box Status", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16, color: Colors.black54)),
                  Text("ID: $displayId", style: const TextStyle(fontSize: 12, color: Colors.grey)),
                ],
              ),
              const SizedBox(height: 20),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceAround,
                children: [
                  _statusItem(
                    icon: Icons.wifi,
                    label: "Network",
                    value: isOnline ? "Online" : "Offline",
                    color: isOnline ? Colors.blue : Colors.grey,
                    bgColor: isOnline ? Colors.blue.shade50 : Colors.grey.shade100,
                  ),
                  _statusItem(
                    icon: isLocked ? Icons.lock : Icons.lock_open,
                    label: "Security",
                    value: isLocked ? "Locked" : "Unlocked",
                    color: isLocked ? Colors.green : Colors.orange,
                    bgColor: isLocked ? Colors.green.shade50 : Colors.orange.shade50,
                  ),
                ],
              ),
            ],
          ),
        ),

        const SizedBox(height: 24),

        // Quick Access
        const Text(
          "Quick Access",
          style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.black87),
        ),
        const SizedBox(height: 16),

        Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(24),
            boxShadow: [
              BoxShadow(
                color: Colors.grey.withOpacity(0.08),
                blurRadius: 20,
                offset: const Offset(0, 10),
              ),
            ],
          ),
          child: Row(
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: isLocked ? Colors.blue.shade50 : Colors.orange.shade50,
                  borderRadius: BorderRadius.circular(16),
                ),
                child: Icon(
                  isLocked ? Icons.lock : Icons.lock_open,
                  size: 32,
                  color: isLocked ? Colors.blue : Colors.orange,
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      isLocked ? "Box is Locked" : "Box is Unlocked",
                      style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      isLocked ? "Tap to unlock" : "Tap to secure box",
                      style: const TextStyle(color: Colors.grey, fontSize: 13),
                    ),
                  ],
                ),
              ),
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: isLocked ? Colors.blue : Colors.orange,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                  elevation: 0,
                ),
                onPressed: isOnline 
                    ? () => _showPinVerifyPopup(context, internalId, isLocked)
                    : null, 
                child: Text(isLocked ? "Unlock" : "Lock"),
              )
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildOfflineCard(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(20),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(24),
        boxShadow: [
          BoxShadow(
            color: Colors.grey.withOpacity(0.08),
            blurRadius: 20,
            offset: const Offset(0, 10),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.password, color: Colors.purple.shade400),
              const SizedBox(width: 12),
              const Text(
                "Offline Access",
                style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
              ),
            ],
          ),
          const SizedBox(height: 12),
          const Text(
            "Box offline? Get a code from your local storage.",
            style: TextStyle(color: Colors.grey, fontSize: 13),
          ),
          const SizedBox(height: 16),
          SizedBox(
            width: double.infinity,
            child: OutlinedButton(
              // ðŸ”¥ UPDATED: Call the Local OTP Dialog
              onPressed: _showLocalOtpDialog,
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                side: BorderSide(color: Colors.purple.shade200),
                foregroundColor: Colors.purple,
              ),
              child: const Text("Get One-Time Code"),
            ),
          ),
        ],
      ),
    );
  }

  Widget _statusItem({
    required IconData icon, 
    required String label, 
    required String value, 
    required Color color,
    required Color bgColor,
  }) {
    return Column(
      children: [
        Container(
          padding: const EdgeInsets.all(16),
          decoration: BoxDecoration(
            color: bgColor,
            shape: BoxShape.circle,
          ),
          child: Icon(icon, color: color, size: 28),
        ),
        const SizedBox(height: 12),
        Text(label, style: const TextStyle(color: Colors.grey, fontSize: 12)),
        const SizedBox(height: 4),
        Text(value, style: TextStyle(color: color, fontWeight: FontWeight.bold, fontSize: 15)),
      ],
    );
  }

  // --- LOCAL OTP DIALOG (READS FROM PHONE) ---
  void _showLocalOtpDialog() async {
    final prefs = await SharedPreferences.getInstance();
    List<String> codes = prefs.getStringList('offline_codes') ?? [];
    int index = prefs.getInt('offline_index') ?? 0;

    if (codes.isEmpty || index >= codes.length) {
      if (mounted) ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("No codes on phone. Connect Box to WiFi to sync.")));
      return;
    }

    String currentCode = codes[index];

    showDialog(
      context: context,
      builder: (dialogCtx) {
        return StatefulBuilder(
          builder: (context, setState) {
            return AlertDialog(
              title: const Text("Offline Access Code"),
              content: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Text("Enter this on keypad:", textAlign: TextAlign.center),
                  const SizedBox(height: 15),
                  Text(currentCode, style: const TextStyle(fontSize: 32, fontWeight: FontWeight.bold, letterSpacing: 4)),
                  const SizedBox(height: 15),
                  const Text("This code will automatically disappear when the device syncs.", style: TextStyle(fontSize: 12, color: Colors.grey), textAlign: TextAlign.center),
                ],
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(dialogCtx),
                  child: const Text("Close"),
                ),
              ],
            );
          },
        );
      },
    );
  }

  // --- EXISTING CONNECT POPUPS (UNCHANGED) ---
  Widget _buildNoBoxState(BuildContext context, String userId) {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(color: Colors.white, borderRadius: BorderRadius.circular(24)),
      child: Column(
        children: [
          const Icon(Icons.add_link, size: 48, color: Colors.blue),
          const SizedBox(height: 16),
          const Text("No Box Connected", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 18)),
          const SizedBox(height: 8),
          const Text("Enter your EBOX ID to get started", style: TextStyle(color: Colors.grey)),
          const SizedBox(height: 24),
          SizedBox(
            width: double.infinity,
            child: ElevatedButton(
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              ),
              onPressed: () => _showConnectPopup(context, userId),
              child: const Text("Connect Box"),
            ),
          ),
        ],
      ),
    );
  }

  void _showConnectPopup(BuildContext context, String userId) {
    final boxIdCtrl = TextEditingController();
    final pinCtrl = TextEditingController();
    final confirmCtrl = TextEditingController();
    String? errorMsg;
    bool loading = false;

    showDialog(
      context: context,
      builder: (dialogContext) {
        return StatefulBuilder(builder: (context, setState) {
          return AlertDialog(
            title: const Text('Connect Box'),
            content: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  if (errorMsg != null) Text(errorMsg!, style: const TextStyle(color: Colors.red)),
                  TextField(controller: boxIdCtrl, decoration: const InputDecoration(labelText: 'EBOX ID')),
                  TextField(controller: pinCtrl, obscureText: true, keyboardType: TextInputType.number, decoration: const InputDecoration(labelText: 'PIN')),
                  TextField(controller: confirmCtrl, obscureText: true, keyboardType: TextInputType.number, decoration: const InputDecoration(labelText: 'Confirm PIN')),
                ],
              ),
            ),
            actions: [
              TextButton(onPressed: () => Navigator.pop(dialogContext), child: const Text('Cancel')),
              ElevatedButton(
                onPressed: loading ? null : () async {
                  setState(() { loading = true; errorMsg = null; });
                  try {
                      final publicId = boxIdCtrl.text.trim();
                      var query = await FirebaseFirestore.instance.collection('boxes').where('publicBoxId', isEqualTo: publicId).limit(1).get();
                      if (query.docs.isEmpty) query = await FirebaseFirestore.instance.collection('boxes').where('boxId', isEqualTo: publicId).limit(1).get();
                      
                      if (query.docs.isEmpty) { setState(() { loading = false; errorMsg = "Invalid ID"; }); return; }
                      
                      final boxDoc = query.docs.first;
                      final data = boxDoc.data();
                      if (data.containsKey('assignedTo') && data['assignedTo'] != null && data['assignedTo'] != "") {
                         setState(() { loading = false; errorMsg = "Assigned"; }); return;
                      }

                      await FirebaseFirestore.instance.collection('boxes').doc(boxDoc.id).update({
                        'assignedTo': userId, 
                        'pinHash': pinCtrl.text.trim(),
                        'isLocked': true,
                        'command': 'LOCK', 
                      });
                      if (context.mounted) Navigator.pop(dialogContext);
                  } catch (e) { setState(() { loading = false; errorMsg = "$e"; }); }
                },
                child: const Text('Connect'),
              ),
            ],
          );
        });
      },
    );
  }

  void _showPinVerifyPopup(BuildContext context, String internalId, bool currentLockState) {
    final pinCtrl = TextEditingController();
    String? errorMsg;
    bool loading = false;

    showDialog(
      context: context,
      builder: (dialogContext) {
        return StatefulBuilder(builder: (context, setState) {
          return AlertDialog(
            title: Text(currentLockState ? 'Unlock' : 'Lock'),
            content: Column(mainAxisSize: MainAxisSize.min, children: [
               if (errorMsg != null) Text(errorMsg!, style: const TextStyle(color: Colors.red)),
               TextField(controller: pinCtrl, obscureText: true, keyboardType: TextInputType.number, decoration: const InputDecoration(labelText: 'PIN')),
            ]),
            actions: [
              TextButton(onPressed: () => Navigator.pop(dialogContext), child: const Text('Cancel')),
              ElevatedButton(
                onPressed: loading ? null : () async {
                  setState(() => loading = true);
                  try {
                    final boxRef = FirebaseFirestore.instance.collection('boxes').doc(internalId);
                    final boxSnap = await boxRef.get();
                    final data = boxSnap.data();
                    final storedPin = (data != null && data.containsKey('pinHash')) ? data['pinHash'] : null;
                    
                    if (pinCtrl.text.trim() != storedPin) { setState(() { loading = false; errorMsg = "Wrong PIN"; }); return; }

                    final newStatus = !currentLockState;
                    await boxRef.update({'isLocked': newStatus, 'command': newStatus ? 'LOCK' : 'UNLOCK'});
                    await boxRef.collection('history').add({'action': newStatus ? 'CLOSE' : 'OPEN', 'timestamp': FieldValue.serverTimestamp(), 'userId': FirebaseAuth.instance.currentUser!.uid});
                    if (context.mounted) Navigator.pop(dialogContext);
                  } catch (e) { setState(() { loading = false; errorMsg = "$e"; }); }
                },
                child: const Text('Confirm'),
              ),
            ],
          );
        });
      },
    );
  }
}

// ==========================================
// ADMIN SETUP SCREEN (PHASE 16 - HARDWARE FIX)
// ==========================================
class AdminSetupScreen extends StatefulWidget {
  final String boxId; 
  const AdminSetupScreen({super.key, required this.boxId});

  @override
  State<AdminSetupScreen> createState() => _AdminSetupScreenState();
}

class _AdminSetupScreenState extends State<AdminSetupScreen> {
  bool _isLoading = false;
  String _status = "Ready to generate codes.";

  // âœ… FIXED GENERATOR: EXCLUDES 3, 6, 9
  List<String> _generateCodes(int count) {
    final rng = Random();
    final Set<String> codes = {};
    
    // We only pick from this "Safe List" of working keys
    const allowedDigits = ['0', '1', '2', '4', '5', '7', '8']; 

    while (codes.length < count) {
      String code = "";
      for (int i = 0; i < 6; i++) {
        // Pick a random digit from the safe list
        code += allowedDigits[rng.nextInt(allowedDigits.length)];
      }
      codes.add(code);
    }
    return codes.toList();
  }

  // 2. UPLOAD LOGIC
  Future<void> _initializeBoxDatabase() async {
    setState(() { _isLoading = true; _status = "Generating 500 safe codes..."; });

    try {
      // A. Generate Master List (Safe Codes Only)
      List<String> allCodes = _generateCodes(500);
      
      // B. Split: First 10 (Current Batch) vs Remaining 490 (Reserve)
      List<String> currentBatch = allCodes.sublist(0, 10);
      List<String> reservePool = allCodes.sublist(10);
      
      // Generate initial Batch ID
      String batchId = DateTime.now().millisecondsSinceEpoch.toString();

      // C. Update Firestore
      await FirebaseFirestore.instance.collection('boxes').doc(widget.boxId).update({
        'offlineCodes': currentBatch, 
        'codePool': reservePool,
        'batchId': batchId,
        'boxSynced': false, 
        'appSynced': false, 
        'offlineIndex': 0, 
      });

      setState(() { _status = "Success! 500 codes generated (No 3, 6, 9).\n10 Active.\n490 Reserve."; });

    } catch (e) {
      setState(() { _status = "Error: $e"; });
    } finally {
      setState(() { _isLoading = false; });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Admin Setup")),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(20),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.build_circle, size: 60, color: Colors.orange),
              const SizedBox(height: 20),
              const Text("Hardware-Safe Init", style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold)),
              const SizedBox(height: 10),
              const Text(
                "Generates 500 codes using only keys:\n1, 2, 4, 5, 7, 8, 0\n(Excludes broken 3, 6, 9)",
                textAlign: TextAlign.center,
                style: TextStyle(color: Colors.grey),
              ),
              const SizedBox(height: 30),
              if (_isLoading) const CircularProgressIndicator(),
              const SizedBox(height: 20),
              Container(
                padding: const EdgeInsets.all(15),
                decoration: BoxDecoration(color: Colors.grey.shade100, borderRadius: BorderRadius.circular(10)),
                child: Text(_status, textAlign: TextAlign.center, style: TextStyle(color: _status.contains("Error") ? Colors.red : Colors.green, fontWeight: FontWeight.bold)),
              ),
              const SizedBox(height: 30),
              ElevatedButton(
                onPressed: _isLoading ? null : _initializeBoxDatabase,
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange, 
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(horizontal: 40, vertical: 20),
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(30)),
                ),
                child: const Text("GENERATE SAFE CODES", style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
              ),
            ],
          ),
        ),
      ),
    );
  }
}