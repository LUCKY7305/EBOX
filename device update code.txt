//current device code 

#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>
#include <EEPROM.h>
#include <ArduinoJson.h> 

// ==========================================
// CONFIGURATION
// ==========================================
#define WIFI_SSID "Lucky123"
#define WIFI_PASSWORD "ekse8tak"

#define FIREBASE_PROJECT_ID "e-box-4fbf2" 
#define API_KEY "AIzaSyC-08DKgGAmg8lclMfUv9Y8osEB8leoxcQ" 

#define RELAY_PIN D1
#define EEPROM_SIZE 64

// TIMING SETTINGS
const long pingInterval = 30000; // Send heartbeat every 30 seconds
unsigned long lastPingTime = 0;

String deviceId; 

// ==========================================
// INTERNAL ID LOGIC
// ==========================================
String randomChar() {
  const char chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  return String(chars[random(36)]);
}

String generateDeviceId() {
  String id = "";
  for (int i = 0; i < 16; i++) id += randomChar();
  return id;
}

void saveDeviceId(String id) {
  EEPROM.begin(EEPROM_SIZE);
  for (int i = 0; i < 16; i++) EEPROM.write(i, id[i]);
  EEPROM.commit();
}

String loadDeviceId() {
  EEPROM.begin(EEPROM_SIZE);
  char id[17];
  for (int i = 0; i < 16; i++) id[i] = EEPROM.read(i);
  id[16] = '\0';
  String sID = String(id);
  if (sID.length() != 16 || !isalnum(sID[0])) return "";
  return sID;
}

// ==========================================
// FIRESTORE REST API FUNCTIONS
// ==========================================
String getDocUrl() {
  return "https://firestore.googleapis.com/v1/projects/" + String(FIREBASE_PROJECT_ID) + 
         "/databases/(default)/documents/boxes/" + deviceId + "?key=" + String(API_KEY);
}

// UPDATE HEARTBEAT (Ping "I am online")
void sendHeartbeat() {
  WiFiClientSecure client;
  client.setInsecure();
  HTTPClient http;

  // Only update 'lastSeen' field
  String url = getDocUrl() + "&updateMask.fieldPaths=lastSeen";
  
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");

  StaticJsonDocument<200> doc;
  JsonObject fields = doc.createNestedObject("fields");
  
  // Create timestamp in ISO 8601 format (simplified, DB will treat as string or you can map it)
  // For Firestore REST, best way to set server time is technically a transform, 
  // but for simplicity we will send a placeholder that tells the App "I updated just now".
  // A better approach for REST API timestamp is to let Firestore set it, but that requires a commit.
  // We will send a dummy value, the APP checks the 'writeTime' metadata or we can simply rely on the fact that the document changed.
  // HOWEVER, to keep it robust: We will use the boolean 'isOnline' = true strategy OR just polling.
  
  // actually, the simplest heartbeat for REST API without NTP is just updating a field.
  // Let's update 'lastSeen' with a dummy value, but rely on the COMMIT TIME returned by Firestore? 
  // No, let's just use the current millis as a "version" or just toggle a bit. 
  // BETTER PLAN: Update a field. 
  
  fields["lastSeen"]["timestampValue"] = "2026-02-01T00:00:00Z"; // This value doesn't matter much if we use a Transform, but let's stick to simple:
  // To make it REAL time, we need NTP. 
  // For now, let's trust that updating the document changes the 'updateTime' metadata in Firestore which we can check.
  
  // Wait! To make the App logic easier, let's use a "serverTimestamp" transform.
  // In REST API, we can't easily do FieldValue.serverTimestamp() like in Flutter.
  // So we will just write a specific status. 
  
  // REVISED STRATEGY: We will stick to the polling check. The read command is the heartbeat.
  // But we need to WRITE to say "I am here".
  // We will simply write the current millis() as a string. The app won't use the time, 
  // the app will use the "metadata.updateTime" of the document!
  fields["activeTicks"]["integerValue"] = millis();

  String jsonString;
  serializeJson(doc, jsonString);
  int httpCode = http.PATCH(jsonString);
  Serial.print("Heartbeat: "); Serial.println(httpCode);
  http.end();
}

void registerBox() {
  WiFiClientSecure client;
  client.setInsecure();
  HTTPClient http;
  String url = getDocUrl() + "&updateMask.fieldPaths=internalId&updateMask.fieldPaths=command";
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");
  StaticJsonDocument<512> doc;
  JsonObject fields = doc.createNestedObject("fields");
  fields["internalId"]["stringValue"] = deviceId;
  fields["command"]["stringValue"] = "NONE"; 
  String jsonString;
  serializeJson(doc, jsonString);
  http.PATCH(jsonString);
  http.end();
}

void checkCommand() {
  WiFiClientSecure client;
  client.setInsecure();
  HTTPClient http;

  http.begin(client, getDocUrl());
  int httpCode = http.GET();

  if (httpCode == 200) {
    String payload = http.getString();
    StaticJsonDocument<1536> doc;
    deserializeJson(doc, payload);

    const char* command = doc["fields"]["command"]["stringValue"];
    String cmdString = String(command);

    if (cmdString == "UNLOCK") {
      Serial.println(">>> EXECUTE: UNLOCK");
      digitalWrite(RELAY_PIN, LOW); 
      resetCommand();
      // Force immediate heartbeat on action
      sendHeartbeat(); 
    } 
    else if (cmdString == "LOCK") {
      Serial.println(">>> EXECUTE: LOCK");
      digitalWrite(RELAY_PIN, HIGH);
      resetCommand();
      sendHeartbeat();
    }
  }
  http.end();
}

void resetCommand() {
  WiFiClientSecure client;
  client.setInsecure();
  HTTPClient http;
  String url = getDocUrl() + "&updateMask.fieldPaths=command";
  http.begin(client, url);
  http.addHeader("Content-Type", "application/json");
  StaticJsonDocument<200> doc;
  JsonObject fields = doc.createNestedObject("fields");
  fields["command"]["stringValue"] = "NONE";
  String jsonString;
  serializeJson(doc, jsonString);
  http.PATCH(jsonString);
  http.end();
}

// ==========================================
// MAIN LOOP
// ==========================================
void setup() {
  Serial.begin(115200);
  delay(1000);
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH); 

  deviceId = loadDeviceId();
  if (deviceId == "") {
    deviceId = generateDeviceId();
    saveDeviceId(deviceId);
  }
  Serial.println("\nINTERNAL ID: " + deviceId);

  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected!");
  
  registerBox();
  sendHeartbeat(); // First heartbeat
}

void loop() {
  // 1. Check for Commands (Fast)
  checkCommand();

  // 2. Send Heartbeat (Every 30 Seconds)
  if (millis() - lastPingTime > pingInterval) {
    lastPingTime = millis();
    sendHeartbeat();
  }
  
  delay(500); // 0.5s delay for responsiveness
}