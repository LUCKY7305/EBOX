
///online lock on off system 

#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>
#include <EEPROM.h>
#include <ArduinoJson.h> 

// ==========================================
// CONFIGURATION
// ==========================================
#define WIFI_SSID "Lucky123"
#define WIFI_PASSWORD "ekse8tak"
#define FIREBASE_PROJECT_ID "e-box-4fbf2" 
#define API_KEY "AIzaSyC-08DKgGAmg8lclMfUv9Y8osEB8leoxcQ" 

#define RELAY_PIN D5 
#define EEPROM_SIZE 64
const long pingInterval = 5000; 
unsigned long lastPingTime = 0;
String deviceId; 

// ==========================================
// HELPER FUNCTIONS
// ==========================================
String randomChar() { const char chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; return String(chars[random(36)]); }
String generateDeviceId() { String id = ""; for (int i = 0; i < 16; i++) id += randomChar(); return id; }
void saveDeviceId(String id) { EEPROM.begin(EEPROM_SIZE); for (int i = 0; i < 16; i++) EEPROM.write(i, id[i]); EEPROM.commit(); }
String loadDeviceId() { EEPROM.begin(EEPROM_SIZE); char id[17]; for (int i = 0; i < 16; i++) id[i] = EEPROM.read(i); id[16] = '\0'; String sID = String(id); if (sID.length() != 16 || !isalnum(sID[0])) return ""; return sID; }
String getBaseUrl() { return "https://firestore.googleapis.com/v1/projects/" + String(FIREBASE_PROJECT_ID) + "/databases/(default)/documents"; }

// ==========================================
// NETWORK FUNCTIONS
// ==========================================

void sendHeartbeat() {
  WiFiClientSecure client; client.setInsecure(); client.setBufferSizes(512, 512);
  HTTPClient http;
  String url = getBaseUrl() + ":commit?key=" + String(API_KEY);
  http.begin(client, url); http.addHeader("Content-Type", "application/json");
  StaticJsonDocument<512> doc;
  JsonArray writes = doc.createNestedArray("writes");
  JsonObject write1 = writes.createNestedObject();
  write1["update"]["name"] = "projects/" + String(FIREBASE_PROJECT_ID) + "/databases/(default)/documents/boxes/" + deviceId;
  JsonObject updateMask = write1.createNestedObject("updateMask");
  updateMask.createNestedArray("fieldPaths").add("lastSeen");
  JsonObject t1 = write1.createNestedArray("updateTransforms").createNestedObject();
  t1["fieldPath"] = "lastSeen"; t1["setToServerValue"] = "REQUEST_TIME";
  String jsonString; serializeJson(doc, jsonString);
  http.POST(jsonString); http.end();
}

void registerBox() {
  WiFiClientSecure client; client.setInsecure(); client.setBufferSizes(512, 512);
  HTTPClient http;
  String url = getBaseUrl() + "/boxes/" + deviceId + "?updateMask.fieldPaths=internalId&updateMask.fieldPaths=command&key=" + String(API_KEY);
  http.begin(client, url); http.addHeader("Content-Type", "application/json");
  StaticJsonDocument<512> doc; doc["fields"]["internalId"]["stringValue"] = deviceId; doc["fields"]["command"]["stringValue"] = "NONE"; 
  String s; serializeJson(doc, s); http.PATCH(s); http.end();
}

void resetCommand() {
  WiFiClientSecure client; client.setInsecure(); client.setBufferSizes(512, 512); 
  HTTPClient http;
  String url = getBaseUrl() + "/boxes/" + deviceId + "?updateMask.fieldPaths=command&key=" + String(API_KEY);
  http.begin(client, url); http.addHeader("Content-Type", "application/json");
  StaticJsonDocument<200> doc; doc["fields"]["command"]["stringValue"] = "NONE";
  String s; serializeJson(doc, s); http.PATCH(s); http.end();
}

// âœ… FIXED CHECK COMMAND (ROLLING WINDOW)
void checkCommand() {
  WiFiClientSecure client;
  client.setInsecure();
  client.setBufferSizes(2048, 512); 

  HTTPClient http;
  String url = getBaseUrl() + "/boxes/" + deviceId + "?key=" + String(API_KEY);
  
  http.begin(client, url);
  int httpCode = http.GET();

  if (httpCode == 200) {
    WiFiClient *stream = http.getStreamPtr();
    String window = ""; // Small buffer to peek at data
    unsigned long timeout = millis();
    
    while (http.connected() && (stream->available() > 0 || millis() - timeout < 2000)) {
       if (stream->available()) {
         char c = stream->read();
         window += c;
         // Keep window small (last 40 chars) so memory never fills up
         if (window.length() > 40) window = window.substring(window.length() - 40);

         // Check for UNLOCK pattern
         if (window.indexOf("stringValue\": \"UNLOCK\"") >= 0) {
            Serial.println(">>> EXECUTE: UNLOCK");
            pinMode(RELAY_PIN, OUTPUT);
            digitalWrite(RELAY_PIN, LOW); // Unlock
            resetCommand();
            break; 
         }
         
         // Check for LOCK pattern
         // Note: "UNLOCK" contains "LOCK", so we check specifically
         if (window.indexOf("stringValue\": \"LOCK\"") >= 0) {
            Serial.println(">>> EXECUTE: LOCK");
            digitalWrite(RELAY_PIN, HIGH); // Lock
            pinMode(RELAY_PIN, INPUT); 
            resetCommand();
            break; 
         }
         
         timeout = millis();
       }
    }
  }
  http.end();
}

// ==========================================
// MAIN LOOP
// ==========================================
void setup() {
  Serial.begin(115200);
  delay(1000);
  
  // Default State: LOCKED
  digitalWrite(RELAY_PIN, HIGH);
  pinMode(RELAY_PIN, INPUT);

  deviceId = loadDeviceId();
  if (deviceId == "") { deviceId = generateDeviceId(); saveDeviceId(deviceId); }
  Serial.println("\nINTERNAL ID: " + deviceId);

  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) { delay(500); Serial.print("."); }
  Serial.println("\nConnected!");
  
  registerBox();
  sendHeartbeat();
}

void loop() {
  checkCommand();

  if (millis() - lastPingTime > pingInterval) {
    lastPingTime = millis();
    sendHeartbeat();
  }
  
  delay(200); 
}