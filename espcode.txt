//espcode


#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>
#include <ArduinoJson.h> 
#include <Keypad.h>
#include <LittleFS.h> 

// ==========================================
// 1. CONFIGURATION
// ==========================================
#define WIFI_SSID "Lucky123"
#define WIFI_PASSWORD "ekse8tak"
#define FIREBASE_PROJECT_ID "e-box-4fbf2" 
#define API_KEY "AIzaSyC-08DKgGAmg8lclMfUv9Y8osEB8leoxcQ" 
#define RELAY_PIN D5 

const long commandCheckInterval = 500; // Fast Online Polling
const long heartbeatInterval = 10000;
unsigned long lastCommandCheck = 0;
unsigned long lastHeartbeat = 0;

String deviceId; 

// Keypad
const byte ROWS = 4; const byte COLS = 3; 
char keys[ROWS][COLS] = {{'1','2','3'},{'4','5','6'},{'7','8','9'},{'*','0','#'}};
byte rowPins[ROWS] = {D1, D2, D3, D7}; byte colPins[COLS] = {D6, D4, D0}; 
Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
String inputBuffer = ""; bool oledAwake = false;

// ==========================================
// 2. HELPER FUNCTIONS
// ==========================================

String randomChar() { const char chars[] = "0123456789"; return String(chars[random(10)]); } // Numeric PINs
String generateDeviceId() { 
    uint8_t mac[6]; WiFi.macAddress(mac);
    String id = ""; for (int i=0; i<6; ++i) { if(mac[i]<0x10) id+="0"; id+=String(mac[i], HEX); }
    id.toUpperCase(); return id;
}
String getBaseUrl() { return "https://firestore.googleapis.com/v1/projects/" + String(FIREBASE_PROJECT_ID) + "/databases/(default)/documents"; }

void unlockBox() { Serial.println(">>> UNLOCKING <<<"); pinMode(RELAY_PIN, OUTPUT); digitalWrite(RELAY_PIN, LOW); }
void lockBox() { Serial.println(">>> LOCKING <<<"); digitalWrite(RELAY_PIN, HIGH); pinMode(RELAY_PIN, INPUT); }

// ==========================================
// 3. OFFLINE LOGIC (WATERMARK DELETION)
// ==========================================

void logHistory(String code) {
  // Store simple history line: "OFFLINE_UNLOCK|<code>|<timestamp_placeholder>"
  File f = LittleFS.open("/history_queue.txt", "a");
  if(f) { f.println("OFFLINE_UNLOCK|" + code); f.close(); }
}

bool checkAndWatermarkDelete(String input) {
  input.trim();
  if (input.length() != 6) return false;

  File f = LittleFS.open("/codes.txt", "r");
  if (!f) { Serial.println("[FS] No codes file."); return false; }

  // We need to find the index of the matching code
  int matchIndex = -1;
  int currentIndex = 0;
  
  // Pass 1: Find the code
  while (f.available()) {
    String line = f.readStringUntil('\n'); line.trim();
    if (line.equals(input)) {
        matchIndex = currentIndex;
        break; 
    }
    currentIndex++;
  }
  f.close();

  if (matchIndex == -1) {
    Serial.println("[Auth] Invalid Code.");
    return false;
  }

  Serial.print("[Auth] Valid Code found at index: "); Serial.println(matchIndex);
  
  // Pass 2: Rewrite file, skipping everything up to matchIndex
  f = LittleFS.open("/codes.txt", "r");
  File temp = LittleFS.open("/temp.txt", "w");
  
  currentIndex = 0;
  int remainingCount = 0;
  while (f.available()) {
    String line = f.readStringUntil('\n'); line.trim();
    if (line.length() == 0) continue;

    // Logic: Delete everything BEFORE and INCLUDING the match
    if (currentIndex > matchIndex) {
        temp.println(line);
        remainingCount++;
    }
    currentIndex++;
  }
  f.close();
  temp.close();

  LittleFS.remove("/codes.txt");
  LittleFS.rename("/temp.txt", "/codes.txt");
  
  Serial.print("[Auth] Watermark deletion complete. Remaining codes: "); Serial.println(remainingCount);
  
  logHistory(input); // Log the event
  return true;
}

// ==========================================
// 4. INITIALIZATION LOGIC (GENERATE 500)
// ==========================================

void generateAndUploadCodes() {
  if (LittleFS.exists("/codes.txt")) {
     File f = LittleFS.open("/codes.txt", "r");
     if (f.size() > 100) { f.close(); return; } // Already has data
     f.close();
  }

  Serial.println("[Init] Generating 500 New PINs...");
  File f = LittleFS.open("/codes.txt", "w");
  
  // 1. Generate & Save Locally
  String batchJson = "{ \"fields\": { \"offlineCodes\": { \"arrayValue\": { \"values\": [";
  
  for(int i=0; i<500; i++) {
     String pin = "";
     for(int j=0; j<6; j++) pin += randomChar();
     
     f.println(pin); // Save to file
     
     // Build JSON (Be careful with memory here, 500 is too big for one string)
     // Strategy: We will upload in chunks or just Init via Console for safety?
     // Actually, 500 JSON objects might crash the string.
     // Better strategy for ESP8266: Generate, Save to File.
     // Then read file line-by-line to build small upload chunks? 
     // No, Firestore array updates replace the whole array.
     // Let's generate 50, not 500, for safety on this specific boot, or assume Admin app did it.
     // USER REQUEST: "Device comes online first time it will generate"
     
     if (i > 0) batchJson += ",";
     batchJson += "{ \"stringValue\": \"" + pin + "\" }";
     
     // ESP8266 RAM Safety: 500 codes is ~10KB JSON. String can handle ~4-5KB max safely.
     // LIMITING TO 100 CODES for stability on ESP8266 auto-gen. 
     // If you really need 500, use the Flutter App Admin button I gave you in Phase 12.
     // Using 100 here to prevent crash.
     if (i >= 99) break; 
  }
  batchJson += "] } } } }";
  f.close();
  
  Serial.println("[Init] Uploading 100 PINs to DB...");
  WiFiClientSecure c; c.setInsecure(); 
  c.setBufferSizes(2048, 512); // Maximize buffer
  HTTPClient h;
  h.begin(c, getBaseUrl() + "/boxes/" + deviceId + "?updateMask.fieldPaths=offlineCodes&key=" + String(API_KEY));
  h.addHeader("Content-Type", "application/json");
  int code = h.PATCH(batchJson);
  Serial.print("[Init] Upload Result: "); Serial.println(code);
  h.end();
}

// ==========================================
// 5. NETWORK LOOPS (HIGH SPEED)
// ==========================================

void registerBox() {
  WiFiClientSecure c; c.setInsecure(); HTTPClient h;
  h.begin(c, getBaseUrl() + "/boxes/" + deviceId + "?updateMask.fieldPaths=internalId&key=" + String(API_KEY));
  h.addHeader("Content-Type", "application/json");
  h.PATCH("{ \"fields\": { \"internalId\": { \"stringValue\": \"" + deviceId + "\" } } }"); h.end();
}

void resetCommand() {
  WiFiClientSecure c; c.setInsecure(); HTTPClient h;
  h.begin(c, getBaseUrl() + "/boxes/" + deviceId + "?updateMask.fieldPaths=command&key=" + String(API_KEY));
  h.addHeader("Content-Type", "application/json");
  h.PATCH("{ \"fields\": { \"command\": { \"stringValue\": \"NONE\" } } }"); h.end();
}

void checkCommand() {
  WiFiClientSecure c; c.setInsecure(); c.setBufferSizes(512, 256); c.setNoDelay(true); HTTPClient h;
  h.begin(c, getBaseUrl() + "/boxes/" + deviceId + "?mask.fieldPaths=command&key=" + String(API_KEY));
  if (h.GET() == 200) {
    String p = h.getString();
    if (p.indexOf("UNLOCK") > 0) { unlockBox(); h.end(); resetCommand(); }
    else if (p.indexOf("LOCK") > 0) { lockBox(); h.end(); resetCommand(); }
  }
  h.end();
}

void sendHeartbeat() {
  WiFiClientSecure c; c.setInsecure(); HTTPClient h;
  h.begin(c, getBaseUrl() + ":commit?key=" + String(API_KEY)); h.addHeader("Content-Type", "application/json");
  h.POST("{ \"writes\": [ { \"update\": { \"name\": \"projects/" + String(FIREBASE_PROJECT_ID) + "/databases/(default)/documents/boxes/" + deviceId + "\"}, \"updateMask\": { \"fieldPaths\": [ \"lastSeen\" ] }, \"updateTransforms\": [ { \"fieldPath\": \"lastSeen\", \"setToServerValue\": \"REQUEST_TIME\" } ] } ] }"); 
  h.end();
}

void uploadOfflineHistory() {
  if (!LittleFS.exists("/history_queue.txt")) return;
  File f = LittleFS.open("/history_queue.txt", "r");
  if (!f) return;
  
  WiFiClientSecure c; c.setInsecure(); HTTPClient h;
  bool ok = true;
  
  while(f.available()) {
    String line = f.readStringUntil('\n'); line.trim();
    if (line.length() < 5) continue;
    // Expected format: OFFLINE_UNLOCK|123456
    int split = line.indexOf('|');
    String code = line.substring(split+1);
    
    Serial.println("[Sync] Uploading History for: " + code);
    
    h.begin(c, getBaseUrl() + ":commit?key=" + String(API_KEY));
    h.addHeader("Content-Type", "application/json");
    
    String docId = "evt" + String(millis());
    String json = "{ \"writes\": [ { \"update\": { \"name\": \"projects/" + String(FIREBASE_PROJECT_ID) + "/databases/(default)/documents/boxes/" + deviceId + "/history/" + docId + "\"}, \"fields\": { \"action\": { \"stringValue\": \"OFFLINE_UNLOCK\" }, \"codeUsed\": { \"stringValue\": \"" + code + "\" }, \"timestamp\": { \"timestampValue\": \"2024-01-01T00:00:00Z\" } } }, { \"transform\": { \"document\": \"projects/" + String(FIREBASE_PROJECT_ID) + "/databases/(default)/documents/boxes/" + deviceId + "/history/" + docId + "\", \"fieldTransforms\": [ { \"fieldPath\": \"timestamp\", \"setToServerValue\": \"REQUEST_TIME\" } ] } } ] }";
    
    if (h.POST(json) != 200) { ok = false; break; }
  }
  f.close();
  if (ok) LittleFS.remove("/history_queue.txt");
}

void setup() {
  Serial.begin(115200); delay(1000);
  LittleFS.begin();
  deviceId = generateDeviceId(); // Or use saved ID
  Serial.println("ID: " + deviceId);
  
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  while (WiFi.status() != WL_CONNECTED) { delay(250); Serial.print("."); }
  Serial.println("\nONLINE");
  
  registerBox();
  generateAndUploadCodes(); // Checks if needs to gen 100 codes
  uploadOfflineHistory();
}

void loop() {
  unsigned long now = millis();

  // Fast Command Poll (0.5s)
  if (now - lastCommandCheck >= commandCheckInterval) {
    lastCommandCheck = now;
    if (WiFi.status() == WL_CONNECTED) checkCommand();
  }

  // Slow Heartbeat & Sync (10s)
  if (now - lastHeartbeat >= heartbeatInterval) {
    lastHeartbeat = now;
    if (WiFi.status() == WL_CONNECTED) {
      sendHeartbeat();
      uploadOfflineHistory();
    }
  }

  // Keypad
  char key = keypad.getKey();
  if (key) {
    if (key == '*') { inputBuffer=""; oledAwake=true; Serial.println("Ready"); }
    else if (oledAwake) {
      inputBuffer += key; Serial.print(key);
      if (inputBuffer.length() == 6) {
        Serial.println();
        if (checkAndWatermarkDelete(inputBuffer)) {
           unlockBox(); delay(5000); lockBox(); oledAwake=false;
        }
        inputBuffer="";
      }
    }
  }
}